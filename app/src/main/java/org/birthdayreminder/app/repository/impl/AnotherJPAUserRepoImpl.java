package org.birthdayreminder.app.repository.impl;

import jakarta.persistence.EntityManager;
import jakarta.persistence.Query;
import org.birthdayreminder.app.entity.UserEntity;
import org.birthdayreminder.app.mapper.UserMapper;
import org.birthdayreminder.domain.model.User;
import org.birthdayreminder.domain.repository.UserRepository;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

/**
 * Class with EntityManager use
 */
public class AnotherJPAUserRepoImpl implements UserRepository {

    private final UserMapper userMapper;
    private final EntityManager entityManager;

    public AnotherJPAUserRepoImpl(UserMapper userMapper, EntityManager entityManager) {
        this.userMapper = userMapper;
        this.entityManager = entityManager;
    }

    /**
     * Method is used for turning on/off the reminder (changes boolean value isReminderActive)
     */
    @Transactional
    @Override
    public void updateUser(User user) {
        Query query = entityManager.createNativeQuery(SQLConstants.UPDATE_REMINDER_STATUS_BY_CHAT_ID, UserEntity.class);
        query.setParameter("chatId", user.getChatId());
        query.executeUpdate();
    }

    /**
     * Checks if user is already registered (present in db)
     */
    @Transactional(readOnly = true)
    @Override
    public Boolean userExists(User user) {
        Query query = entityManager.createNativeQuery(SQLConstants.SELECT_BY_CHAT_ID, UserEntity.class);
        query.setParameter("chatId", user.getChatId());
        return !query.getResultList().isEmpty();
    }

    /**
     * After the check userExists, saves new user and returns id (generated by db)
     * or
     * returns id via getUserIdSubQuery (TODO: DB constraint for user duplicates)
     */
    @Transactional
    @Override
    public Long saveNewUser(User user) {
        if (userExists(user)) {
            return getUserIdSubQuery(user);
        }
        UserEntity entity = userMapper.toEntity(user);
        entityManager.persist(entity);
        entityManager.flush();
        return entity.getId();
    }

    /**
     * To get user by id (generated as seq)
     */
    @Transactional(readOnly = true)
    @Override
    public Optional<User> getUserById(Long id) {
        return Optional.of(userMapper.toModel(entityManager.find(UserEntity.class, id)));
    }

    /**
     * To get user by chat_id (TG unique identifier)
     */
    @Transactional(readOnly = true)
    @Override
    public Optional<User> getUserByChatId(Long chatId) {
        Query query = entityManager.createNativeQuery(SQLConstants.SELECT_BY_CHAT_ID, UserEntity.class);
        query.setParameter("chatId", chatId);
        return Optional.of(userMapper.toModel((UserEntity) query.getSingleResult()));
    }

    /**
     * Method to return id (which is PK) of existing user
     */
    public long getUserIdSubQuery(User user) {
        UserEntity userEntity = (UserEntity) entityManager.createNativeQuery(SQLConstants.SELECT_BY_CHAT_ID, UserEntity.class)
                .setParameter("chatId", user.getChatId())
                .getResultList().getFirst();
        return userEntity.getId();
    }
}
